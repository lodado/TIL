# 동기 & 비동기


      for(let i=0; i<this.events[name].length; i++){

            let ele = this.events[name][i];
            let pro = new Promise(function (resolve, reject) {
                setTimeout(resolve(), 0);
            }).then(ele).catch(e=>console.log("오류"));
        }

  setTimeout 함수와 promise를 사용하여 비동기 상황을 연출 할 수 있다.
  
  ### emit 
  

  ![image](https://user-images.githubusercontent.com/40421183/128026557-5d054052-e8ec-4e0f-ab33-fd6b83891f42.png)


순수 자바스크립트는 동기적으로 작동한다. 한 번에 하나의 프로세스만 실행시킬 수 있다. 

하지만 인터넷 환경에서 동기적으로 작업한다면 어떤 작업을 하는동안 웹 브라우저는 멈춰있을 수 밖에 없게 되고

최대한 리소스를 많이 활용하기 위해서 가능하다면 비동기적으로 작업하는 것이 최선이라고 한다.

그래서 병렬적으로 실행 가능한 setTimeout, setInterval 등 타이머 작업 혹은 DB 연결, 파일 읽기/쓰기, HTTP 요청 등 

모든 비동기 작업들은 libuv를 통해 스케줄링 되었다가 이벤트 루프의 순환 주기에 따라 호출된다.




# 모듈간 소통 방법 

비동기 상황에서 만약 어떤 작업을 처리하고 유저한테 알려주고 싶다면 callback 함수를 적용해야 한다.

그런데 많은 callback함수및 모듈끼리 서로 참조하다보면 유지보수가 어려워지게 된다.

그래서 콜백 및 참조를 통한 모듈간 소통보다는 서로의 상태를 보다가 변화하고, 알려줄때가 오면 상대 모듈에게 필요한 데이터를 넘겨주는 식으로

서로 소통하게 된다.

이것을 옵저버 패턴이라고 한다. 





reference

emit

https://www.huskyhoochu.com/nodejs-eventemitter/

emit
https://www.huskyhoochu.com/nodejs-eventemitter/
